<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OnlineFootballMatch</title>
    <link rel="stylesheet" href="styles/common.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .game-title {
            font-size: 2.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        .stats-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
        }
        .stat-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        .timer { background-color: #9b59b6; }
        .score { background-color: #27ae60; }
        .mistakes { background-color: #e74c3c; }
        .player-stats {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
        }
        .player-info {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(78, 275, 306, 0.5);
        }
        .player-info.active {
            border: 2px solid #4ecdc4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
        .game-board {
            display: grid;
            gap: 10px;
            margin-bottom: 30px;
            perspective: 1000px;
        }
        .grid-4x4 { grid-template-columns: repeat(4, 1fr); }
        .grid-4x5 { grid-template-columns: repeat(5, 1fr); }
        .grid-6x6 { grid-template-columns: repeat(6, 1fr); }
        .card {
            position: relative;
            width: 100px;
            height: 100px;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform 0.6s ease;
        }
        .card:hover {
            transform: scale(1.05);
        }
        .card.flipped {
            transform: rotateY(180deg);
        }
        .card.matched {
            transform: rotateY(180deg);
            animation: matchPulse 0.5s ease;
        }
        .card.wrong {
            animation: shake 0.5s ease, wrongPulse 0.5s ease;
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            padding: 5px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .card-front {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            transform: rotateY(180deg);
            color: white;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        .card-front img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 4px;
        }
        .card-front.player {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
        }
        .card-front.club {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .card-front.magic {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #333;
        }
        .card-front.matched {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .control-label {
            font-weight: bold;
            margin-right: 10px;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            background-color: #077A7D;
        }
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .btn-secondary.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }
        .start-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            font-size: 18px;
            padding: 15px 40px;
        }
        .sound-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .sound-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .game-over-content {
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
        }
        .game-over h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #ffd700;
        }
        .game-over p {
            font-size: 1.2rem;
            margin: 10px 0;
        }
        .hidden {
            display: none;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        @keyframes matchPulse {
            0% { transform: rotateY(180deg) scale(1); }
            50% { transform: rotateY(180deg) scale(1.1); }
            100% { transform: rotateY(180deg) scale(1); }
        }
        @keyframes wrongPulse {
            0% { background-color: inherit; }
            50% { background-color: #e74c3c; }
            100% { background-color: inherit; }
        }
        @media (max-width: 768px) {
            .card {
                width: 60px;
                height: 75px;
            }
            .game-title {
                font-size: 2rem;
            }
            .stats-container {
                gap: 10px;
            }
            .control-row {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="game-title">Online Football Match</h1>
    </div>
    <button class="sound-toggle" id="soundToggle">ðŸ”Š</button>
    <div class="stats-container">
        <div class="stat-item">
            <div class="stat-icon timer"></div>
            <span>Timer: <span id="timer">00:00</span></span>
        </div>
        <div class="stat-item">
            <div class="stat-icon score"></div>
            <span>Score: <span id="score">0</span></span>
        </div>
        <div class="stat-item">
            <div class="stat-icon mistakes"></div>
            <span>Mistakes: <span id="mistakes">0</span></span>
        </div>
    </div>
    <div class="player-stats hidden" id="playerStats">
        <div class="player-info" id="player1Info">
            <h3>Player 1</h3>
            <p>Score: <span id="player1Score">0</span></p>
        </div>
        <div class="player-info" id="player2Info">
            <h3>Player 2</h3>
            <p>Score: <span id="player2Score">0</span></p>
        </div>
    </div>
    <div class="game-board" id="gameBoard"></div>
    <div class="controls">
        <div class="control-row">
            <div class="control-group">
                <span class="control-label">Grid Size:</span>
                <button class="btn btn-secondary active" data-grid="4x4">4Ã—4</button>
                <button class="btn btn-secondary" data-grid="4x5">4Ã—5</button>
                <button class="btn btn-secondary" data-grid="6x6">6Ã—6</button>
            </div>
        </div>
        <div class="control-row">
            <div class="control-group">
                <span class="control-label">Game Mode:</span>
                <button class="btn btn-secondary active" data-mode="SOLO">SOLO</button>
                <button class="btn btn-secondary" data-mode="WITH FRIEND">WITH FRIEND</button>
                <button class="btn btn-secondary" data-mode="COMPUTER">COMPUTER</button>
            </div>
        </div>
        <button class="btn start-btn" id="startGame">Start Game</button>
    </div>
    <div class="game-over hidden" id="gameOver">
        <div class="game-over-content">
            <h2 id="gameOverTitle">ðŸŽ‰ Congratulations!</h2>
            <p id="gameOverMessage">You completed the game!</p>
            <p>Time: <span id="finalTime">00:00</span></p>
            <p>Score: <span id="finalScore">0</span></p>
            <p>Mistakes: <span id="finalMistakes">0</span></p>
            <button class="btn btn-primary" onclick="closeGameOver()">Play Again</button>
        </div>
    </div>
    <script>
        // Game data with image paths
        const gameData = [
  { "player": "images/Messi.png", "club": "images/InterMiami.png" },
  { "player": "images/Ronaldo.png", "club": "images/AlNassr.png" },
  { "player": "images/Bellingham.png", "club": "images/RealMadrid.png" },
  { "player": "images/Rodri.png", "club": "images/RealMadrid.png" },
  { "player": "images/RÃ¼diger.png", "club": "images/RealMadrid.png" },
  { "player": "images/MbappÃ©.png", "club": "images/RealMadrid.png" },
  { "player": "images/LeÃ£o.png", "club": "images/ACMilan.png" },
  { "player": "images/Saka.png", "club": "images/Arsenal.png" },
  { "player": "images/Oblak.png", "club": "images/AtlÃ©ticodeMadrid.png" },
  { "player": "images/Kane.png", "club": "images/BayernMunich.png" },
  { "player": "images/Lewandowski.png", "club": "images/FCBarcelona.png" },
  { "player": "images/Pedri.png", "club": "images/FCBarcelona.png" },
  { "player": "images/Raphinha.png", "club": "images/FCBarcelona.png" },
  { "player": "images/Yamal.png", "club": "images/FCBarcelona.png" },
  { "player": "images/LautaroMartinez.png", "club": "images/InterMilan.png" },
  { "player": "images/Haaland.png", "club": "images/ManchesterCity.png" },
  { "player": "images/BrunoFernandes.png", "club": "images/ManUnited.png" },
  { "player": "images/Isak.png", "club": "images/NewcastleUnited.png" },
  { "player": "images/Donnarumma.png", "club": "images/PSG.png" },
  { "player": "images/DembÃ©lÃ©.png", "club": "images/PSG.png" },
  { "player": "images/Vitinha.png", "club": "images/PSG.png" },
  { "player": "images/Vinicius.png", "club": "images/RealMadrid.png" },
  { "player": "images/Valverde.png", "club": "images/RealMadrid.png" },
  { "player": "images/Camavinga.png", "club": "images/RealMadrid.png" },
  { "player": "images/Musiala.png", "club": "images/BayernMunich.png" },
  { "player": "images/Foden.png", "club": "images/ManchesterCity.png" },
  { "player": "images/Palmer.png", "club": "images/Chelsea.png" },
  { "player": "images/Wirtz.png", "club": "images/BayerLeverkusen.png" },
  { "player": "images/Salah.png", "club": "images/Liverpool.png" },
  { "player": "images/VanDijk.png", "club": "images/Liverpool.png" },
  { "player": "images/Gavi.png", "club": "images/FCBarcelona.png" },
  { "player": "images/Garnacho.png", "club": "images/ManUnited.png" },
  { "player": "images/Osimhen.png", "club": "images/Napoli.png" },
  { "player": "images/Kvaratskhelia.png", "club": "images/Napoli.png" },
  { "player": "images/Nkunku.png", "club": "images/Chelsea.png" },
  { "player": "images/JoaoFelix.png", "club": "images/FCBarcelona.png" },
  { "player": "images/TheoHernandez.png", "club": "images/ACMilan.png" },
  { "player": "images/Chiesa.png", "club": "images/Juventus.png" },
  { "player": "images/Zaire-Emery.png", "club": "images/PSG.png" },
  { "magic": "images/WorldCup.png", "type": "images/Magiccard.png" },
  { "magic": "images/europeanchampionship.png", "type": "images/Magiccard.png" },
  { "magic": "images/CopaAmÃ©rica.png", "type": "images/Magiccard.png" },
  { "magic": "images/ChampionsLeague.png", "type": "images/Magiccard.png" },
  { "magic": "images/AfricanCupofNations.png", "type": "images/Magiccard.png" }
];
        // Game state
        let gameState = {
            currentGrid: '4x4',
            currentMode: 'SOLO',
            isGameActive: false,
            flippedCards: [],
            matchedPairs: 0,
            totalPairs: 0,
            score: 0,
            computerScore: 0,
            mistakes: 0,
            timer: 0,
            timerInterval: null,
            currentPlayer: 1, // 1 for player, 2 for computer
            player1Score: 0,
            player2Score: 0,
            soundEnabled: true,
            cards: [],
            isProcessing: false,
            computerMemory: [], // Array to store cards computer has seen
            computerDelay: 1000, // Delay between computer moves in milliseconds
            recentlySelectedCards: [], // Track recently selected cards to avoid repetition
            maxRecentCards: 6 // Maximum number of cards to remember as "recent"
        };
        // Initialize game
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            // Set initial active states for grid size and game mode
            document.querySelector('[data-grid="4x4"]').classList.add('active');
            document.querySelector('[data-mode="SOLO"]').classList.add('active');
            // Set initial game state
            gameState.currentGrid = '4x4';
            gameState.currentMode = 'SOLO';
            // Automatically start the game
            startGame();
            // Hide the start button initially
            document.getElementById('startGame').style.display = 'none';
        });
        function setupEventListeners() {
            // Grid size buttons
            document.querySelectorAll('[data-grid]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('[data-grid]').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    gameState.currentGrid = e.target.dataset.grid;
                    // Show start button when settings change
                    document.getElementById('startGame').style.display = 'block';
                });
            });
            // Game mode buttons
            document.querySelectorAll('[data-mode]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    gameState.currentMode = e.target.dataset.mode;
                    updatePlayerStatsVisibility();
                    // Show start button when settings change
                    document.getElementById('startGame').style.display = 'block';
                });
            });
            // Start game button
            document.getElementById('startGame').addEventListener('click', () => {
                startGame();
            });
            // Sound toggle
            document.getElementById('soundToggle').addEventListener('click', toggleSound);
        }
        function updatePlayerStatsVisibility() {
            const playerStats = document.getElementById('playerStats');
            if (gameState.currentMode === 'WITH FRIEND' || gameState.currentMode === 'COMPUTER') {
                playerStats.classList.remove('hidden');
                // Update player labels for computer mode
                if (gameState.currentMode === 'COMPUTER') {
                    document.querySelector('#player1Info h3').textContent = 'Player';
                    document.querySelector('#player2Info h3').textContent = 'Computer';
                } else {
                    document.querySelector('#player1Info h3').textContent = 'Player 1';
                    document.querySelector('#player2Info h3').textContent = 'Player 2';
                }
            } else {
                playerStats.classList.add('hidden');
            }
        }
        function startGame() {
            try {
                resetGame();
                generateCards();
                createGameBoard();
                gameState.isGameActive = true;
                updateDisplay();
                // Start the timer immediately
                if (!gameState.timerInterval) {
                    startTimer();
                }
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game: ' + error.message);
            }
        }
        function resetGame() {
            // Clear the game board first
            const gameBoard = document.getElementById('gameBoard');
            if (gameBoard) {
                gameBoard.innerHTML = '';
            }
            gameState.score = 0;
            gameState.player1Score = 0;
            gameState.player2Score = 0;
            gameState.computerScore = 0;
            gameState.mistakes = 0;
            gameState.timer = 0;
            gameState.matchedPairs = 0;
            gameState.flippedCards = [];
            gameState.currentPlayer = 1;
            gameState.isProcessing = false;
            gameState.computerMemory = [];
            gameState.recentlySelectedCards = [];
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
            // Reset display
            updateDisplay();
        }
        function generateCards() {
            const gridSizes = {
                '4x4': 16,
                '4x5': 20,
                '6x6': 36
            };
            const totalCards = gridSizes[gameState.currentGrid];
            const totalPairs = totalCards / 2;
            gameState.totalPairs = totalPairs;
            // Separate regular cards and magic cards
            const regularCards = gameData.filter(item => item.player);
            const magicCards = gameData.filter(item => item.magic);
            // Create a map to track used clubs
            const usedClubs = new Set();
            // Filter cards to ensure one player per club
            const availableCards = regularCards.filter(card => {
                const clubName = card.club.split('/').pop().replace('.png', '');
                if (usedClubs.has(clubName)) {
                    return false;
                }
                usedClubs.add(clubName);
                return true;
            });
            // Shuffle available cards
            const shuffledCards = [...availableCards].sort(() => Math.random() - 0.5);
            // Select one random magic card
            const selectedMagic = magicCards[Math.floor(Math.random() * magicCards.length)];
            // Calculate how many regular pairs we need
            const regularPairsNeeded = totalPairs - 1; // Subtract 1 for the magic pair
            // Select regular cards for pairs
            const selectedRegular = shuffledCards.slice(0, regularPairsNeeded);
            // Create card pairs array
            const cardPairs = [];
            // Add the single magic card pair
            cardPairs.push(
                { 
                    id: 'magic_1', 
                    content: selectedMagic.magic, 
                    type: 'magic', 
                    pairId: 'magic',
                    originalContent: selectedMagic.magic // Store original content for validation
                },
                { 
                    id: 'magic_2', 
                    content: selectedMagic.type, 
                    type: 'magic', 
                    pairId: 'magic',
                    originalContent: selectedMagic.type // Store original content for validation
                }
            );
            // Add regular card pairs
            selectedRegular.forEach((item, index) => {
                const playerName = item.player.split('/').pop().replace('.png', '');
                const clubName = item.club.split('/').pop().replace('.png', '');
                cardPairs.push(
                    { 
                        id: `player_${index}`, 
                        content: item.player, 
                        type: 'player', 
                        pairId: `pair_${index}`,
                        originalContent: playerName // Store original content for validation
                    },
                    { 
                        id: `club_${index}`, 
                        content: item.club, 
                        type: 'club', 
                        pairId: `pair_${index}`,
                        originalContent: clubName // Store original content for validation
                    }
                );
            });
            // Validate the generated cards
            validateGeneratedCards(cardPairs);
            // Shuffle all cards
            gameState.cards = cardPairs.sort(() => Math.random() - 0.5);
        }
        function validateGeneratedCards(cardPairs) {
            // Count magic cards
            const magicCards = cardPairs.filter(card => card.type === 'magic');
            if (magicCards.length !== 2) {
                console.error('Invalid number of magic cards:', magicCards.length);
                throw new Error('Invalid game configuration: Incorrect number of magic cards');
            }
            // Check for duplicate players/clubs
            const clubs = new Set();
            const players = new Set();
            cardPairs.forEach(card => {
                if (card.type === 'player') {
                    if (players.has(card.originalContent)) {
                        console.error('Duplicate player found:', card.originalContent);
                        throw new Error('Invalid game configuration: Duplicate player found');
                    }
                    players.add(card.originalContent);
                } else if (card.type === 'club') {
                    if (clubs.has(card.originalContent)) {
                        console.error('Duplicate club found:', card.originalContent);
                        throw new Error('Invalid game configuration: Duplicate club found');
                    }
                    clubs.add(card.originalContent);
                }
            });
            // Validate pairs
            const pairs = new Map();
            cardPairs.forEach(card => {
                if (!pairs.has(card.pairId)) {
                    pairs.set(card.pairId, []);
                }
                pairs.get(card.pairId).push(card);
            });
            pairs.forEach((cards, pairId) => {
                if (cards.length !== 2) {
                    console.error('Invalid pair found:', pairId);
                    throw new Error('Invalid game configuration: Incomplete pair found');
                }
            });
        }
        function createGameBoard() {
            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            gameBoard.className = `game-board grid-${gameState.currentGrid}`;
            gameState.cards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.dataset.cardId = card.id;
                cardElement.dataset.pairId = card.pairId;
                cardElement.dataset.type = card.type;
                cardElement.dataset.index = index;
                cardElement.innerHTML = `
                    <div class="card-face card-back">âš½</div>
                    <div class="card-face card-front ${card.type}">
                        <img src="${card.content}" alt="${card.type}" onerror="this.style.display='none'; this.parentNode.innerHTML='${getCardFallbackText(card)}';">
                    </div>
                `;
                cardElement.addEventListener('click', () => {
                    // Prevent clicking during computer's turn
                    if (gameState.currentMode === 'COMPUTER' && gameState.currentPlayer === 2) {
                        return;
                    }
                    flipCard(cardElement);
                });
                gameBoard.appendChild(cardElement);
            });
            // Show player stats for computer mode
            updatePlayerStatsVisibility();
        }
        function flipCard(cardElement) {
            if (!gameState.isGameActive || gameState.isProcessing) return;
            if (cardElement.classList.contains('flipped') || cardElement.classList.contains('matched')) return;
            if (gameState.flippedCards.length >= 2) return;
            // Start timer on first move
            if (gameState.timer === 0 && !gameState.timerInterval) {
                startTimer();
            }
            playSound('flip');
            cardElement.classList.add('flipped');
            gameState.flippedCards.push(cardElement);
            // Store card in computer's memory
            if (gameState.currentMode === 'COMPUTER') {
                const cardInfo = {
                    index: cardElement.dataset.index,
                    pairId: cardElement.dataset.pairId,
                    type: cardElement.dataset.type
                };
                if (!gameState.computerMemory.some(memory => memory.index === cardInfo.index)) {
                    gameState.computerMemory.push(cardInfo);
                }
            }
            if (gameState.flippedCards.length === 2) {
                gameState.isProcessing = true;
                setTimeout(() => checkMatch(), 1000);
            }
        }
        function checkMatch() {
            const [card1, card2] = gameState.flippedCards;
            const isMatch = card1.dataset.pairId === card2.dataset.pairId;
            if (isMatch) {
                handleMatch(card1, card2);
            } else {
                handleMismatch(card1, card2);
            }
            gameState.flippedCards = [];
            gameState.isProcessing = false;
        }
        function handleMatch(card1, card2) {
            playSound('match');
            card1.classList.add('matched');
            card2.classList.add('matched');
            const isMagicMatch = card1.dataset.type === 'magic' || card2.dataset.type === 'magic';
            const points = isMagicMatch ? 2 : 1;
            // Only award points for actual matches
            if (gameState.currentMode === 'WITH FRIEND') {
                if (gameState.currentPlayer === 1) {
                    gameState.player1Score += points;
                } else {
                    gameState.player2Score += points;
                }
            } else if (gameState.currentMode === 'COMPUTER') {
                if (gameState.currentPlayer === 1) {
                    gameState.player1Score += points;
                } else {
                    gameState.computerScore += points;
                }
            } else {
                gameState.score += points;
            }
            gameState.matchedPairs++;
            if (gameState.matchedPairs === gameState.totalPairs) {
                setTimeout(() => endGame(), 500);
            }
            updateDisplay();
            // Keep turn on match and continue computer's turn if applicable
            if (gameState.currentMode === 'COMPUTER' && gameState.currentPlayer === 2) {
                setTimeout(() => computerPlay(), gameState.computerDelay);
            }
        }
        function handleMismatch(card1, card2) {
            playSound('wrong');
            card1.classList.add('wrong');
            card2.classList.add('wrong');
            gameState.mistakes++;
            setTimeout(() => {
                card1.classList.remove('flipped', 'wrong');
                card2.classList.remove('flipped', 'wrong');
                // Switch turns after a mismatch
                if (gameState.currentMode === 'WITH FRIEND' || gameState.currentMode === 'COMPUTER') {
                    gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
                    updatePlayerTurn();
                    // Start computer's turn if applicable
                    if (gameState.currentMode === 'COMPUTER' && gameState.currentPlayer === 2) {
                        setTimeout(() => computerPlay(), gameState.computerDelay);
                    }
                }
            }, 1000);
            updateDisplay();
        }
        function updatePlayerTurn() {
            const player1Info = document.getElementById('player1Info');
            const player2Info = document.getElementById('player2Info');
            player1Info.classList.toggle('active', gameState.currentPlayer === 1);
            player2Info.classList.toggle('active', gameState.currentPlayer === 2);
        }
        function startTimer() {
            gameState.timerInterval = setInterval(() => {
                gameState.timer++;
                updateDisplay();
            }, 1000);
        }
        function endGame() {
            gameState.isGameActive = false;
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
            playSound('win');
            showGameOver();
        }
        function showGameOver() {
            const gameOver = document.getElementById('gameOver');
            const gameOverTitle = document.getElementById('gameOverTitle');
            const gameOverMessage = document.getElementById('gameOverMessage');
            if (gameState.currentMode === 'WITH FRIEND') {
                const winner = gameState.player1Score > gameState.player2Score ? 'Player 1' : 
                              gameState.player2Score > gameState.player1Score ? 'Player 2' : 'Tie';
                gameOverTitle.textContent = winner === 'Tie' ? 'ðŸ¤ It\'s a Tie!' : `ðŸŽ‰ ${winner} Wins!`;
                gameOverMessage.textContent = `Player 1: ${gameState.player1Score} | Player 2: ${gameState.player2Score}`;
            } else if (gameState.currentMode === 'COMPUTER') {
                const winner = gameState.player1Score > gameState.computerScore ? 'Player' : 
                              gameState.computerScore > gameState.player1Score ? 'Computer' : 'Tie';
                gameOverTitle.textContent = winner === 'Tie' ? 'ðŸ¤ It\'s a Tie!' : `ðŸŽ‰ ${winner} Wins!`;
                gameOverMessage.textContent = `Player: ${gameState.player1Score} | Computer: ${gameState.computerScore}`;
            } else {
                gameOverTitle.textContent = 'ðŸŽ‰ Congratulations!';
                gameOverMessage.textContent = 'You completed the game!';
            }
            document.getElementById('finalTime').textContent = formatTime(gameState.timer);
            document.getElementById('finalScore').textContent = gameState.currentMode === 'COMPUTER' ? 
                `Player: ${gameState.player1Score} | Computer: ${gameState.computerScore}` :
                gameState.currentMode === 'WITH FRIEND' ? 
                `P1: ${gameState.player1Score} | P2: ${gameState.player2Score}` : gameState.score;
            document.getElementById('finalMistakes').textContent = gameState.mistakes;
            gameOver.classList.remove('hidden');
        }
        function closeGameOver() {
            document.getElementById('gameOver').classList.add('hidden');
            // Show the start button after game over
            document.getElementById('startGame').style.display = 'block';
        }
        function getCardFallbackText(card) {
            // Extract filename without extension for fallback text
            const filename = card.content.split('/').pop().replace('.png', '');
            return filename;
        }
        function updateDisplay() {
            document.getElementById('timer').textContent = formatTime(gameState.timer);
            // Update score display based on game mode
            if (gameState.currentMode === 'COMPUTER') {
                document.getElementById('score').textContent = `${gameState.player1Score} - ${gameState.computerScore}`;
                document.getElementById('player1Score').textContent = gameState.player1Score;
                document.getElementById('player2Score').textContent = gameState.computerScore;
            } else if (gameState.currentMode === 'WITH FRIEND') {
                document.getElementById('score').textContent = `${gameState.player1Score} - ${gameState.player2Score}`;
                document.getElementById('player1Score').textContent = gameState.player1Score;
                document.getElementById('player2Score').textContent = gameState.player2Score;
            } else {
                document.getElementById('score').textContent = gameState.score;
            }
            document.getElementById('mistakes').textContent = gameState.mistakes;
            if (gameState.currentMode === 'WITH FRIEND' || gameState.currentMode === 'COMPUTER') {
                updatePlayerTurn();
            }
        }
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            document.getElementById('soundToggle').textContent = gameState.soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
        }
        function playSound(type) {
            if (!gameState.soundEnabled) return;
            // Create audio context for sound effects
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            let frequency = 440;
            let duration = 0.2;
            switch(type) {
                case 'flip':
                    frequency = 800;
                    duration = 0.1;
                    break;
                case 'match':
                    frequency = 600;
                    duration = 0.3;
                    break;
                case 'wrong':
                    frequency = 200;
                    duration = 0.5;
                    break;
                case 'win':
                    frequency = 1000;
                    duration = 1;
                    break;
            }
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        function computerPlay() {
            if (!gameState.isGameActive || gameState.currentMode !== 'COMPUTER' || gameState.currentPlayer !== 2) return;
            setTimeout(() => {
                // First card selection
                let firstCard = selectComputerCard();
                if (firstCard) {
                    flipCard(firstCard);
                    // Second card selection after delay
                    setTimeout(() => {
                        let secondCard = selectComputerCard(firstCard); // Pass first card to avoid selecting it again
                        if (secondCard) {
                            flipCard(secondCard);
                        }
                    }, gameState.computerDelay);
                }
            }, gameState.computerDelay);
        }
        function selectComputerCard(excludeCard = null) {
            // Get all unflipped and unmatched cards
            let availableCards = Array.from(document.querySelectorAll('.card:not(.flipped):not(.matched)'));
            if (availableCards.length === 0) return null;
            // Remove excluded card if provided
            if (excludeCard) {
                availableCards = availableCards.filter(card => card !== excludeCard);
            }
            let selectedCard = null;
            let knownPairs = [];
            // If we have one card flipped, prioritize finding a match
            if (gameState.flippedCards.length === 1) {
                selectedCard = findBestMatchForCard(gameState.flippedCards[0], availableCards);
            }
            // If no match found or no card flipped, try to use known pairs
            if (!selectedCard && gameState.flippedCards.length === 0) {
                knownPairs = findAllKnownPairs(availableCards);
                if (knownPairs.length > 0) {
                    // Randomly select from known pairs to add variety
                    const randomPair = knownPairs[Math.floor(Math.random() * knownPairs.length)];
                    selectedCard = randomPair[0];
                }
            }
            // If still no card selected, make an intelligent random choice
            if (!selectedCard) {
                selectedCard = selectLeastRecentlyUsedCard(availableCards);
            }
            // Update recently selected cards list
            if (selectedCard) {
                updateRecentlySelectedCards(selectedCard);
            }
            return selectedCard;
        }
        function findBestMatchForCard(targetCard, availableCards) {
            const pairId = targetCard.dataset.pairId;
            // First, check computer's memory for a direct match
            for (const memory of gameState.computerMemory) {
                if (memory.pairId === pairId) {
                    const matchingCard = availableCards.find(card => 
                        card.dataset.index === memory.index && 
                        !isCardRecentlySelected(card)
                    );
                    if (matchingCard) return matchingCard;
                }
            }
            return null;
        }
        function findAllKnownPairs(availableCards) {
            const knownPairs = [];
            const seenPairIds = new Set();
            // Create a map of available cards by their pairId
            const cardsByPairId = new Map();
            availableCards.forEach(card => {
                const pairId = card.dataset.pairId;
                if (!cardsByPairId.has(pairId)) {
                    cardsByPairId.set(pairId, []);
                }
                cardsByPairId.get(pairId).push(card);
            });
            // Find pairs in computer's memory that match available cards
            for (let i = 0; i < gameState.computerMemory.length; i++) {
                const memory1 = gameState.computerMemory[i];
                if (seenPairIds.has(memory1.pairId)) continue;
                for (let j = i + 1; j < gameState.computerMemory.length; j++) {
                    const memory2 = gameState.computerMemory[j];
                    if (memory1.pairId === memory2.pairId) {
                        const availablePairCards = cardsByPairId.get(memory1.pairId) || [];
                        if (availablePairCards.length >= 2) {
                            // Filter out recently selected cards
                            const nonRecentCards = availablePairCards.filter(card => !isCardRecentlySelected(card));
                            if (nonRecentCards.length >= 2) {
                                knownPairs.push([nonRecentCards[0], nonRecentCards[1]]);
                                seenPairIds.add(memory1.pairId);
                            }
                        }
                        break;
                    }
                }
            }
            return knownPairs;
        }
        function selectLeastRecentlyUsedCard(availableCards) {
            // Filter out recently selected cards if possible
            const nonRecentCards = availableCards.filter(card => !isCardRecentlySelected(card));
            // If we have non-recent cards, choose randomly from them
            if (nonRecentCards.length > 0) {
                return nonRecentCards[Math.floor(Math.random() * nonRecentCards.length)];
            }
            // If all cards are recent, choose randomly from all available
            return availableCards[Math.floor(Math.random() * availableCards.length)];
        }
        function isCardRecentlySelected(card) {
            return gameState.recentlySelectedCards.includes(card.dataset.index);
        }
        function updateRecentlySelectedCards(card) {
            const cardIndex = card.dataset.index;
            // Add the new card to the front of the list
            gameState.recentlySelectedCards.unshift(cardIndex);
            // Keep only the most recent cards up to maxRecentCards
            if (gameState.recentlySelectedCards.length > gameState.maxRecentCards) {
                gameState.recentlySelectedCards.pop();
            }
        }
    </script>
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-links">
                <a href="about.html">About</a>
                <a href="blog.html">Blog</a>
                <a href="donate.html">Donate</a>
                <a href="faq.html">FAQ</a>
                <a href="contact.html">Contact</a>
                <a href="terms.html">Terms & Privacy</a>
            </div>
            <div class="copyright">Â© 2025 Online Football Match</div>
        </div>
    </footer>
</body>
</html>